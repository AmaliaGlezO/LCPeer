#!/usr/bin/env python3

import socket
import threading
import time
import uuid
import os
import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
from datetime import datetime
import json

# Protocol Constants
LCP_PORT = 9990
UDP_MAX_SIZE = 65507
BROADCAST_ADDR = "255.255.255.0"
HEADER_SIZE = 100
RESPONSE_SIZE = 25
OPERATION_ECHO = 0
OPERATION_MESSAGE = 1
OPERATION_FILE = 2
STATUS_OK = 0
STATUS_BAD_REQUEST = 1
STATUS_INTERNAL_ERROR = 2
TIMEOUT = 5  # seconds

class ChatHistory:
    """Manages chat history for message recovery"""
    
    def __init__(self, max_messages=10):
        self.max_messages = max_messages
        self.history = {}
        self.history_file = "lcp_chat_history.json"
        self.load_history()
        
    def add_message(self, user_id, message, outgoing=True):
        """Add a message to history"""
        if user_id not in self.history:
            self.history[user_id] = []
            
        self.history[user_id].append({
            "timestamp": datetime.now().isoformat(),
            "content": message,
            "outgoing": outgoing
        })
        
        # Keep only the last max_messages
        if len(self.history[user_id]) > self.max_messages:
            self.history[user_id] = self.history[user_id][-self.max_messages:]
        
        # Save history
        self.save_history()
        
    def get_history(self, user_id):
        """Get message history for a user"""
        return self.history.get(user_id, [])
    
    def save_history(self):
        """Save history to file"""
        try:
            with open(self.history_file, 'w') as f:
                json.dump(self.history, f)
        except Exception as e:
            print(f"Error saving history: {e}")
    
    def load_history(self):
        """Load history from file"""
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    self.history = json.load(f)
        except Exception as e:
            print(f"Error loading history: {e}")
            self.history = {}


class LCPChat:
    """Main LCP Chat implementation"""
    
    def __init__(self):
        # Generate a unique user ID (max 20 bytes)
        user_id = str(uuid.uuid4()).replace('-', '')[:20]
        self.user_id = user_id.encode('utf-8').ljust(20)  # Pad to exactly 20 bytes
        
        # Create UDP socket for control messages
        self.udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        self.udp_socket.bind(('', LCP_PORT))
        
        # For TCP server (file transfers)
        self.tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.tcp_server.bind(('', LCP_PORT))
        self.tcp_server.listen(5)
        
        # Active neighbors
        self.neighbors = {}  # {user_id: (ip, last_seen)}
        
        # Message and file counters
        self.next_body_id = 0
        
        # Chat history
        self.history = ChatHistory()
        
        # Groups
        self.groups = {}  # {group_name: [member_ids]}
        self.user_groups = {}  # {user_id: group_name}
        
        # For GUI
        self.main_window = None
        self.chat_text = None
        self.users_listbox = None
        self.entry_message = None
        self.active_chat = None
        
        # Start threads
        self.running = True
        self.udp_thread = threading.Thread(target=self.handle_udp)
        self.udp_thread.daemon = True
        self.udp_thread.start()
        
        self.tcp_thread = threading.Thread(target=self.handle_tcp)
        self.tcp_thread.daemon = True
        self.tcp_thread.start()
        
        self.discovery_thread = threading.Thread(target=self.periodic_discovery)
        self.discovery_thread.daemon = True
        self.discovery_thread.start()
    
    def get_body_id(self):
        """Get next unique message/file ID"""
        body_id = self.next_body_id
        self.next_body_id = (self.next_body_id + 1) % 256  # Keep in byte range
        return body_id
    
    def periodic_discovery(self):
        """Periodically broadcast discovery messages"""
        while self.running:
            self.discover_neighbors()
            time.sleep(30)  # Discover every 30 seconds
    
    def discover_neighbors(self):
        """Send echo request to discover neighbors"""
        header = self.create_header(
            user_id_to=b'\xFF' * 20,  # Broadcast
            operation=OPERATION_ECHO,
            body_id=0,
            body_length=0
        )
        
        try:
            self.udp_socket.sendto(header, (BROADCAST_ADDR, LCP_PORT))
        except Exception as e:
            print(f"Discovery error: {e}")
    
    def create_header(self, user_id_to, operation, body_id=0, body_length=0):
        """Create an LCP header"""
        header = bytearray(HEADER_SIZE)
        
        # UserIdFrom (20 bytes)
        header[0:20] = self.user_id
        
        # UserIdTo (20 bytes)
        header[20:40] = user_id_to
        
        # OperationCode (1 byte)
        header[40] = operation
        
        # BodyId (1 byte)
        header[41] = body_id
        
        # BodyLength (8 bytes)
        header[42:50] = body_length.to_bytes(8, byteorder='big')
        
        # Reserved (50 bytes) - leave as zeros
        return header
    
    def create_response(self, status):
        """Create an LCP response"""
        response = bytearray(RESPONSE_SIZE)
        
        # ResponseStatus (1 byte)
        response[0] = status
        
        # ResponseId (20 bytes)
        response[1:21] = self.user_id
        
        # Reserved (4 bytes) - leave as zeros
        return response
    
    def handle_udp(self):
        """Handle incoming UDP packets"""
        while self.running:
            try:
                data, addr = self.udp_socket.recvfrom(UDP_MAX_SIZE)
                
                if len(data) < HEADER_SIZE:
                    continue  # Ignore invalid packets
                
                # Parse header
                user_id_from = data[0:20]
                user_id_to = data[20:40]
                operation = data[40]
                body_id = data[41]
                body_length = int.from_bytes(data[42:50], byteorder='big')
                
                # Check if the message is for us
                if user_id_to != self.user_id and user_id_to != b'\xFF' * 20:
                    continue
                
                # Handle different operations
                if operation == OPERATION_ECHO:
                    # Send echo response
                    response = self.create_response(STATUS_OK)
                    self.udp_socket.sendto(response, addr)
                    
                    # Update neighbors list (if not ourselves)
                    if user_id_from != self.user_id:
                        user_id_str = user_id_from.rstrip(b'\x00').decode('utf-8')
                        self.neighbors[user_id_str] = (addr[0], time.time())
                        
                        # Update GUI if running
                        if self.main_window:
                            self.update_users_list()
                
                elif operation == OPERATION_MESSAGE:
                    # Send OK response
                    response = self.create_response(STATUS_OK)
                    self.udp_socket.sendto(response, addr)
                    
                    # Receive message body
                    if body_length > 0:
                        body_data, _ = self.udp_socket.recvfrom(body_length + 8)  # +8 for message ID
                        body_message_id = body_data[0:8]
                        message = body_data[8:].decode('utf-8')
                        
                        # Save to history and update GUI
                        user_id_str = user_id_from.rstrip(b'\x00').decode('utf-8')
                        self.history.add_message(user_id_str, message, outgoing=False)
                        
                        if self.main_window:
                            # Update chat window if this is the active chat
                            if self.active_chat == user_id_str:
                                self.chat_text.config(state=tk.NORMAL)
                                self.chat_text.insert(tk.END, f"{user_id_str}: {message}\n")
                                self.chat_text.config(state=tk.DISABLED)
                                self.chat_text.see(tk.END)
                            else:
                                # Highlight the user in the list to indicate new message
                                pass
                
                elif operation == OPERATION_FILE:
                    # Send OK response to initiate file transfer
                    response = self.create_response(STATUS_OK)
                    self.udp_socket.sendto(response, addr)
                    
                    # TCP transfer will be handled by the TCP thread
                    
            except Exception as e:
                print(f"UDP error: {e}")
    
    def handle_tcp(self):
        """Handle incoming TCP connections for file transfers"""
        while self.running:
            try:
                client_socket, addr = self.tcp_server.accept()
                
                # Start a new thread to handle this file transfer
                file_thread = threading.Thread(
                    target=self.handle_file_receive,
                    args=(client_socket, addr)
                )
                file_thread.daemon = True
                file_thread.start()
                
            except Exception as e:
                print(f"TCP accept error: {e}")
    
    def handle_file_receive(self, client_socket, addr):
        """Handle file reception over TCP"""
        try:
            # Read file ID (first 8 bytes)
            file_id_data = client_socket.recv(8)
            file_id = int.from_bytes(file_id_data, byteorder='big')
            
            # Create a temporary file name
            timestamp = int(time.time())
            filename = f"received_file_{timestamp}_{file_id}"
            
            # Receive the file data
            with open(filename, 'wb') as f:
                while True:
                    chunk = client_socket.recv(4096)
                    if not chunk:
                        break
                    f.write(chunk)
            
            # Send success response
            response = self.create_response(STATUS_OK)
            client_socket.sendall(response)
            
            # Update GUI
            if self.main_window:
                messagebox.showinfo("File Received", f"File saved as {filename}")
                
        except Exception as e:
            print(f"File receive error: {e}")
            # Try to send error response
            try:
                response = self.create_response(STATUS_INTERNAL_ERROR)
                client_socket.sendall(response)
            except:
                pass
        finally:
            client_socket.close()
    
    def send_message(self, user_id_str, message):
        """Send a message to a specific user"""
        if user_id_str not in self.neighbors:
            return False
        
        try:
            # Find user's IP
            ip, _ = self.neighbors[user_id_str]
            
            # Convert user_id_str to fixed 20 bytes
            user_id_to = user_id_str.encode('utf-8').ljust(20, b'\x00')
            
            # Get message body ID
            body_id = self.get_body_id()
            
            # Encode message
            message_bytes = message.encode('utf-8')
            body_length = len(message_bytes) + 8  # +8 for message ID
            
            # Create and send header
            header = self.create_header(
                user_id_to=user_id_to,
                operation=OPERATION_MESSAGE,
                body_id=body_id,
                body_length=body_length
            )
            
            self.udp_socket.sendto(header, (ip, LCP_PORT))
            
            # Wait for response
            self.udp_socket.settimeout(TIMEOUT)
            response, _ = self.udp_socket.recvfrom(RESPONSE_SIZE)
            self.udp_socket.settimeout(None)
            
            if response[0] != STATUS_OK:
                return False
            
            # Send message body
            body_data = body_id.to_bytes(8, byteorder='big') + message_bytes
            self.udp_socket.sendto(body_data, (ip, LCP_PORT))
            
            # Save to history
            self.history.add_message(user_id_str, message, outgoing=True)
            
            # Update GUI
            if self.main_window and self.active_chat == user_id_str:
                self.chat_text.config(state=tk.NORMAL)
                self.chat_text.insert(tk.END, f"You: {message}\n")
                self.chat_text.config(state=tk.DISABLED)
                self.chat_text.see(tk.END)
            
            return True
            
        except Exception as e:
            print(f"Send message error: {e}")
            return False
    
    def send_file(self, user_id_str, file_path):
        """Send a file to a specific user"""
        if user_id_str not in self.neighbors:
            return False
        
        try:
            # Check if file exists
            if not os.path.exists(file_path):
                return False
            
            # Get file size
            file_size = os.path.getsize(file_path)
            
            # Find user's IP
            ip, _ = self.neighbors[user_id_str]
            
            # Convert user_id_str to fixed 20 bytes
            user_id_to = user_id_str.encode('utf-8').ljust(20, b'\x00')
            
            # Get file body ID
            body_id = self.get_body_id()
            
            # Create and send header via UDP
            header = self.create_header(
                user_id_to=user_id_to,
                operation=OPERATION_FILE,
                body_id=body_id,
                body_length=file_size
            )
            
            self.udp_socket.sendto(header, (ip, LCP_PORT))
            
            # Wait for response
            self.udp_socket.settimeout(TIMEOUT)
            response, _ = self.udp_socket.recvfrom(RESPONSE_SIZE)
            self.udp_socket.settimeout(None)
            
            if response[0] != STATUS_OK:
                return False
            
            # Transfer file via TCP
            tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            tcp_socket.connect((ip, LCP_PORT))
            
            # Send file ID
            tcp_socket.sendall(body_id.to_bytes(8, byteorder='big'))
            
            # Send file content
            with open(file_path, 'rb') as f:
                while True:
                    chunk = f.read(4096)
                    if not chunk:
                        break
                    tcp_socket.sendall(chunk)
            
            # Close connection and wait for response
            tcp_socket.shutdown(socket.SHUT_WR)
            response = tcp_socket.recv(RESPONSE_SIZE)
            tcp_socket.close()
            
            return response[0] == STATUS_OK
            
        except Exception as e:
            print(f"Send file error: {e}")
            return False
    
    def create_group(self, group_name):
        """Create a new chat group"""
        if group_name in self.groups:
            return False
        
        self.groups[group_name] = [self.user_id.decode('utf-8').strip('\x00')]
        return True
    
    def join_group(self, group_name, user_id_str):
        """Join a group (for extension)"""
        if group_name not in self.groups:
            return False
        
        if user_id_str not in self.groups[group_name]:
            self.groups[group_name].append(user_id_str)
        
        self.user_groups[user_id_str] = group_name
        return True
    
    def send_group_message(self, group_name, message):
        """Send a message to all members of a group"""
        if group_name not in self.groups:
            return False
        
        success = True
        for user_id in self.groups[group_name]:
            if user_id != self.user_id.decode('utf-8').strip('\x00'):
                if not self.send_message(user_id, f"[{group_name}] {message}"):
                    success = False
        
        return success
    
    def create_gui(self):
        """Create the chat GUI"""
        self.main_window = tk.Tk()
        self.main_window.title(f"LCP Chat - {self.user_id.decode('utf-8').strip('\x00')}")
        self.main_window.geometry("800x600")
        
        # Main frame
        main_frame = ttk.Frame(self.main_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Left frame for users list
        left_frame = ttk.Frame(main_frame, width=200)
        left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        
        # User list label
        users_label = ttk.Label(left_frame, text="Online Users")
        users_label.pack(anchor=tk.W, pady=(0, 5))
        
        # Users listbox with scrollbar
        users_frame = ttk.Frame(left_frame)
        users_frame.pack(fill=tk.BOTH, expand=True)
        
        self.users_listbox = tk.Listbox(users_frame)
        self.users_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        users_scrollbar = ttk.Scrollbar(users_frame, orient=tk.VERTICAL, command=self.users_listbox.yview)
        users_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.users_listbox.config(yscrollcommand=users_scrollbar.set)
        
        # User selection event
        self.users_listbox.bind('<<ListboxSelect>>', self.on_user_select)
        
        # Right frame for chat
        right_frame = ttk.Frame(main_frame)
        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # Chat area with scrollbar
        chat_frame = ttk.Frame(right_frame)
        chat_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        self.chat_text = scrolledtext.ScrolledText(chat_frame, state=tk.DISABLED)
        self.chat_text.pack(fill=tk.BOTH, expand=True)
        
        # Input area
        input_frame = ttk.Frame(right_frame)
        input_frame.pack(fill=tk.X)
        
        self.entry_message = ttk.Entry(input_frame)
        self.entry_message.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        self.entry_message.bind('<Return>', self.on_send_message)
        
        send_button = ttk.Button(input_frame, text="Send", command=self.on_send_message)
        send_button.pack(side=tk.LEFT)
        
        # File button
        file_button = ttk.Button(input_frame, text="Send File", command=self.on_send_file)
        file_button.pack(side=tk.LEFT, padx=(5, 0))
        
        # Initial discovery
        self.discover_neighbors()
        
        # Update the users list
        self.update_users_list()
        
        # Set up window close event
        self.main_window.protocol("WM_DELETE_WINDOW", self.on_close)
        
        # Start the GUI main loop
        self.main_window.mainloop()
    
    def update_users_list(self):
        """Update the users list in the GUI"""
        if not self.main_window:
            return
        
        self.users_listbox.delete(0, tk.END)
        
        # Add all neighbors
        for user_id in sorted(self.neighbors.keys()):
            self.users_listbox.insert(tk.END, user_id)
    
    def on_user_select(self, event):
        """Handle user selection from the list"""
        selection = self.users_listbox.curselection()
        if not selection:
            return
        
        user_id = self.users_listbox.get(selection[0])
        self.active_chat = user_id
        
        # Clear chat window
        self.chat_text.config(state=tk.NORMAL)
        self.chat_text.delete(1.0, tk.END)
        
        # Load chat history
        history = self.history.get_history(user_id)
        for msg in history:
            prefix = "You" if msg["outgoing"] else user_id
            self.chat_text.insert(tk.END, f"{prefix}: {msg['content']}\n")
        
        self.chat_text.config(state=tk.DISABLED)
        self.chat_text.see(tk.END)
    
    def on_send_message(self, event=None):
        """Send a message to the active chat"""
        if not self.active_chat:
            messagebox.showinfo("Info", "Select a user to chat with first.")
            return
        
        message = self.entry_message.get().strip()
        if not message:
            return
        
        # Clear input
        self.entry_message.delete(0, tk.END)
        
        # Send the message
        self.send_message(self.active_chat, message)
    
    def on_send_file(self):
        """Send a file to the active chat"""
        if not self.active_chat:
            messagebox.showinfo("Info", "Select a user to send a file to first.")
            return
        
        file_path = filedialog.askopenfilename()
        if not file_path:
            return
        
        # Send the file
        if self.send_file(self.active_chat, file_path):
            messagebox.showinfo("Success", "File sent successfully.")
        else:
            messagebox.showerror("Error", "Failed to send file.")
    
    def on_close(self):
        """Handle window close event"""
        self.running = False
        self.main_window.destroy()
        
        # Close sockets
        try:
            self.udp_socket.close()
            self.tcp_server.close()
        except:
            pass


if __name__ == "__main__":
    chat = LCPChat()
    chat.create_gui()
